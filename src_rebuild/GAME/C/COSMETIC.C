#include "THISDUST.H"
#include "COSMETIC.H"
#include "SYSTEM.H"
#include "MISSION.H"
#include "HANDLING.H"
#include "CARS.H"
#include "DEBRIS.H"
#include "PAUSE.H"
#include "CAMERA.H"
#include "DIRECTOR.H"
#include "MAIN.H"

#include <string.h>

char* CosmeticFiles[] = {
	"LEVELS\\CHICAGO.LCF",
	"LEVELS\\HAVANA.LCF",
	"LEVELS\\VEGAS.LCF",
	"LEVELS\\RIO.LCF",
};


// decompiled code
// original method signature: 
// void /*$ra*/ LoadCosmetics(int level /*$a0*/)
 // line 188, offset 0x00031160
	/* begin block 1 */
		// Start line: 190
		// Start offset: 0x00031160
	/* end block 1 */
	// End offset: 0x000311B0
	// End Line: 203

	/* begin block 2 */
		// Start line: 376
	/* end block 2 */
	// End Line: 377

	/* begin block 3 */
		// Start line: 2374
	/* end block 3 */
	// End Line: 2375

	/* begin block 4 */
		// Start line: 2381
	/* end block 4 */
	// End Line: 2382

char _cosmeticBuffer[3120];

// [D]
void LoadCosmetics(int level)
{
	LoadfileSeg(CosmeticFiles[level], _cosmeticBuffer, 0, sizeof(_cosmeticBuffer));
	ProcessCosmeticsLump(_cosmeticBuffer, 0);
}



// decompiled code
// original method signature: 
// void /*$ra*/ ProcessCosmeticsLump(char *lump_ptr /*$s2*/, int lump_size /*$a1*/)
 // line 213, offset 0x000311b0
	/* begin block 1 */
		// Start line: 214
		// Start offset: 0x000311B0
		// Variables:
	// 		int i; // $t0
	// 		int model; // $a1
	// 		int offset; // $a0

		/* begin block 1.1 */
			// Start line: 236
			// Start offset: 0x00031238
		/* end block 1.1 */
		// End offset: 0x00031338
		// End Line: 240
	/* end block 1 */
	// End offset: 0x00031360
	// End Line: 243

	/* begin block 2 */
		// Start line: 2415
	/* end block 2 */
	// End Line: 2416

	/* begin block 3 */
		// Start line: 2426
	/* end block 3 */
	// End Line: 2427

CAR_COSMETICS car_cosmetics[5];
CAR_COSMETICS dummyCosmetics = { 0 };

void ProcessCosmeticsLump(char *lump_ptr, int lump_size)
{
	long *plVar1;
	long lVar2;
	int externalModelNumber;
	char* ptr;
	CAR_COSMETICS *pCVar3;
	int i = 0;

	do {
		externalModelNumber = MissionHeader->residentModels[i];

		if (externalModelNumber == 0xd) 
		{
			externalModelNumber = 10 - (MissionHeader->residentModels[0] + MissionHeader->residentModels[1] + MissionHeader->residentModels[2]);

			if (externalModelNumber < 1) 
			{
				externalModelNumber = 1;
			}
			else if (4 < externalModelNumber) 
			{
				externalModelNumber = 4;
			}
		}

		if (externalModelNumber != -1) 
		{
			pCVar3 = &car_cosmetics[i];
			ptr = (lump_ptr + *(int *)(lump_ptr + externalModelNumber * 4));

			memcpy(&car_cosmetics[i], ptr, sizeof(CAR_COSMETICS));

			FixCarCos(&car_cosmetics[i], externalModelNumber);
		}
		i++;
	} while (i < 5);
}



// decompiled code
// original method signature: 
// void /*$ra*/ AddReverseLight(struct _CAR_DATA *cp /*$s1*/)
 // line 252, offset 0x0002f994
	/* begin block 1 */
		// Start line: 253
		// Start offset: 0x0002F994
		// Variables:
	// 		struct CAR_COSMETICS *car_cos; // $a1
	// 		struct SVECTOR v1; // stack offset -32
	// 		struct CVECTOR col; // stack offset -24
	// 		short cogOffset; // $s2
	/* end block 1 */
	// End offset: 0x0002FAEC
	// End Line: 283

	/* begin block 2 */
		// Start line: 504
	/* end block 2 */
	// End Line: 505

	/* begin block 3 */
		// Start line: 510
	/* end block 3 */
	// End Line: 511

/* WARNING: Could not reconcile some variable overlaps */

void AddReverseLight(_CAR_DATA *cp)
{
	UNIMPLEMENTED();
	/*
	short sVar1;
	uint uVar2;
	CAR_COSMETICS *pCVar3;
	undefined4 local_20;
	uint local_1c;
	CVECTOR local_18[2];

	if (cp < car_data) {
		while (FrameCnt != 0x78654321) {
			trap(0x400);
		}
	}
	local_18[0].r = 'd';
	pCVar3 = (cp->ap).carCos;
	local_18[0].g = 'Z';
	local_18[0].b = 'Z';
	sVar1 = (pCVar3->cog).vx;
	uVar2 = *(uint *)&(pCVar3->revLight).vz;
	local_20._0_2_ = (short)*(undefined4 *)&pCVar3->revLight;
	local_20._2_2_ = (short)((uint)*(undefined4 *)&pCVar3->revLight >> 0x10);
	local_20._0_2_ = sVar1 + (short)local_20;
	local_20._2_2_ = local_20._2_2_ + (pCVar3->cog).vy;
	local_1c._0_2_ = (short)uVar2;
	local_1c = uVar2 & 0xffff0000 | (uint)(ushort)((short)local_1c + (pCVar3->cog).vz);
	if ((cp->ap).damage[4] < 500) {
		ShowCarlight((SVECTOR *)&local_20, cp, local_18, 0xe, &light_texture, 0);
	}
	if ((cp->ap).damage[3] < 500) {
		local_20 = CONCAT22(local_20._2_2_, sVar1 * 2 - (short)local_20);
		ShowCarlight((SVECTOR *)&local_20, cp, local_18, 0xe, &light_texture, 0);
	}
	return;*/
}



// decompiled code
// original method signature: 
// void /*$ra*/ SetupSpecCosmetics(char *loadbuffer /*$a0*/)
 // line 293, offset 0x00031360
	/* begin block 1 */
		// Start line: 298
		// Start offset: 0x00031360
		// Variables:
	// 		int *to; // $a1
	// 		int *from; // $a0
	// 		int *end; // $v1
	/* end block 1 */
	// End offset: 0x00031398
	// End Line: 311

	/* begin block 2 */
		// Start line: 2564
	/* end block 2 */
	// End Line: 2565

	/* begin block 3 */
		// Start line: 2615
	/* end block 3 */
	// End Line: 2616

	/* begin block 4 */
		// Start line: 2619
	/* end block 4 */
	// End Line: 2620

// [D]
void SetupSpecCosmetics(char *loadbuffer)
{
	// [A] this is better
	memcpy(&car_cosmetics[4], loadbuffer, sizeof(CAR_COSMETICS));
}



// decompiled code
// original method signature: 
// void /*$ra*/ AddIndicatorLight(struct _CAR_DATA *cp /*$s0*/, int Type /*$s6*/)
 // line 325, offset 0x0002faec
	/* begin block 1 */
		// Start line: 326
		// Start offset: 0x0002FAEC
		// Variables:
	// 		struct CAR_COSMETICS *car_cos; // $a1
	// 		struct CVECTOR col; // stack offset -56
	// 		struct SVECTOR vfrnt; // stack offset -48
	// 		struct SVECTOR vback; // stack offset -40
	// 		char tempcol; // $s1
	// 		char *life; // $a0
	// 		char *life2; // $s3
	// 		short cogOffset; // $s2
	/* end block 1 */
	// End offset: 0x0002FDBC
	// End Line: 397

	/* begin block 2 */
		// Start line: 623
	/* end block 2 */
	// End Line: 624

	/* begin block 3 */
		// Start line: 666
	/* end block 3 */
	// End Line: 667

/* WARNING: Could not reconcile some variable overlaps */

void AddIndicatorLight(_CAR_DATA *cp, int Type)
{
	UNIMPLEMENTED();
	/*
	byte bVar1;
	short sVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	char *pcVar6;
	CAR_COSMETICS *pCVar7;
	uchar uVar8;
	char *pcVar9;
	CVECTOR local_38[2];
	uint local_30;
	uint local_2c;
	short local_28;
	short sStack38;
	uint local_24;

	pcVar6 = &(cp->ap).life;
	pcVar9 = &(cp->ap).life2;
	if ((cp->ap).life < '\0') {
		uVar3 = (0xff - (uint)(byte)(cp->ap).life) * 2;
	}
	else {
		uVar3 = (uint)(byte)(cp->ap).life << 1;
	}
	local_38[0].r = (uchar)uVar3;
	uVar3 = uVar3 & 0xff;
	if (cp < car_data) {
		while (FrameCnt != 0x78654321) {
			trap(0x400);
		}
	}
	bVar1 = cp->controlType;
	if (bVar1 == 2) {
		local_38[0].g = '\0';
		local_38[0].b = '\0';
		if (pauseflag == 0) {
			*pcVar6 = *pcVar6 + '\b';
		}
		pCVar7 = (cp->ap).carCos;
		sVar2 = (pCVar7->cog).vx;
		uVar4 = *(uint *)&(pCVar7->backInd).vz;
		uVar5 = *(uint *)&(pCVar7->frontInd).vz;
		local_28 = (short)*(undefined4 *)&pCVar7->backInd;
		sStack38 = (short)((uint)*(undefined4 *)&pCVar7->backInd >> 0x10);
		local_28 = sVar2 + local_28;
		local_24._0_2_ = (short)uVar4;
		sStack38 = sStack38 + (pCVar7->cog).vy;
		local_30._0_2_ = (short)*(undefined4 *)&pCVar7->frontInd;
		local_24 = uVar4 & 0xffff0000 | (uint)(ushort)((short)local_24 + (pCVar7->cog).vz);
		local_2c._0_2_ = (short)uVar5;
		local_30 = CONCAT22((short)((uint)*(undefined4 *)&pCVar7->frontInd >> 0x10) + (pCVar7->cog).vy,
			sVar2 + (short)local_30);
		local_2c = uVar5 & 0xffff0000 | (uint)(ushort)((short)local_2c + (pCVar7->cog).vz);
		uVar8 = (uchar)uVar3;
		if ((Type == 0) || (Type == (uint)bVar1)) {
			if ((cp->ap).damage[4] < 500) {
				*pcVar9 = *pcVar9 + (char)(uVar3 >> 3);
				ShowCarlight((SVECTOR *)&local_28, cp, local_38, 0x14, &light_texture, 0);
			}
			if ((cp->ap).damage[0] < 500) {
				local_38[0].r = uVar8;
				ShowCarlight((SVECTOR *)&local_30, cp, local_38, 0x14, &light_texture, 1);
			}
		}
		if (Type - 1U < 2) {
			if ((cp->ap).damage[3] < 500) {
				local_28 = sVar2 * 2 - local_28;
				*pcVar9 = *pcVar9 + (char)(uVar3 >> 3);
				local_38[0].r = uVar8;
				ShowCarlight((SVECTOR *)&local_28, cp, local_38, 0x14, &light_texture, 0);
			}
			if ((cp->ap).damage[1] < 500) {
				local_30 = local_30 & 0xffff0000 | (uint)(ushort)(sVar2 * 2 - (short)local_30);
				local_38[0].r = uVar8;
				ShowCarlight((SVECTOR *)&local_30, cp, local_38, 0x14, &light_texture, 1);
			}
		}
	}
	return;*/
}



// decompiled code
// original method signature: 
// void /*$ra*/ AddBrakeLight(struct _CAR_DATA *cp /*$s5*/)
 // line 407, offset 0x0002fde4
	/* begin block 1 */
		// Start line: 408
		// Start offset: 0x0002FDE4
		// Variables:
	// 		struct CAR_COSMETICS *car_cos; // $a1
	// 		struct SVECTOR v1; // stack offset -88
	// 		struct SVECTOR v2; // stack offset -80
	// 		struct SVECTOR vec; // stack offset -72
	// 		struct CVECTOR col; // stack offset -64
	// 		char *life2; // $s2
	// 		short doubleFlag; // stack offset -56
	// 		short verticalFlag; // stack offset -52
	// 		short offset; // $s1
	// 		short loop; // $fp
	// 		short damIndex; // $v0
	// 		short cogOffset; // $a3
	/* end block 1 */
	// End offset: 0x00030118
	// End Line: 504

	/* begin block 2 */
		// Start line: 867
	/* end block 2 */
	// End Line: 868

/* WARNING: Could not reconcile some variable overlaps */

void AddBrakeLight(_CAR_DATA *cp)
{
	UNIMPLEMENTED();
	/*
	short sVar1;
	ushort uVar2;
	short sVar3;
	int iVar4;
	uint uVar5;
	SVECTOR *v1;
	CAR_COSMETICS *pCVar6;
	int iVar7;
	char *pcVar8;
	short *psVar9;
	int iVar10;
	short local_58;
	short sStack86;
	uint local_54;
	undefined4 local_50;
	uint local_4c;
	short local_48;
	short sStack70;
	uint local_44;
	CVECTOR local_40[2];
	int local_38;
	int local_34;
	int local_30;

	pCVar6 = (cp->ap).carCos;
	local_40[0].r = -0x38;
	local_40[0].g = '\0';
	local_40[0].b = '\0';
	uVar2 = pCVar6->extraInfo;
	sVar1 = (pCVar6->cog).vx;
	pcVar8 = &(cp->ap).life2;
	if ((uVar2 & 8) != 0) {
		uVar5 = *(uint *)&(pCVar6->brakeLight).vz;
		local_48 = (short)*(undefined4 *)&pCVar6->brakeLight;
		sStack70 = (short)((uint)*(undefined4 *)&pCVar6->brakeLight >> 0x10);
		local_48 = sVar1 + local_48;
		sStack70 = sStack70 + (pCVar6->cog).vy;
		local_44._0_2_ = (short)uVar5;
		iVar7 = (((uint)(ushort)pCVar6->extraInfo & 0x300) >> 6) + 10;
		local_38 = (int)(short)(uVar2 & 0x4000);
		local_44 = uVar5 & 0xffff0000 | (uint)(ushort)((short)local_44 + (pCVar6->cog).vz);
		local_34 = (int)(short)(uVar2 & 0x1000);
		if ((pCVar6->extraInfo & 8U) != 0) {
			iVar10 = 0;
			psVar9 = (cp->ap).damage;
			local_30 = (int)sVar1 << 1;
			do {
				iVar4 = (4 - iVar10) * 0x10000 >> 0x10;
				sVar1 = (short)iVar7;
				if (local_38 == 0) {
					local_58 = local_48;
					sStack86 = sStack70;
					local_54 = local_44;
					v1 = (SVECTOR *)&local_58;
					if (psVar9[iVar4] < 500) goto LAB_000300c8;
				}
				else {
					local_54._0_2_ = (short)local_44;
					v1 = (SVECTOR *)&local_50;
					if (local_34 == 0) {
						sVar3 = psVar9[iVar4] >> 6;
						local_54 = local_44 & 0xffff0000 | (uint)(ushort)((short)local_54 + sVar3);
						local_4c = local_44 & 0xffff0000 | (uint)(ushort)((short)local_54 + sVar3);
						local_58 = sVar1 + local_48;
						sStack86 = sStack70;
						local_50 = CONCAT22(sStack70, local_48 - sVar1);
						if (psVar9[iVar4] < 500) {
							ShowCarlight((SVECTOR *)&local_58, cp, local_40, 0x11, &light_texture, 0);
							goto LAB_000300c8;
						}
					}
					else {
						sVar3 = psVar9[iVar4] >> 6;
						local_54 = local_44 & 0xffff0000 | (uint)(ushort)((short)local_54 + sVar3);
						local_4c = local_44 & 0xffff0000 | (uint)(ushort)((short)local_54 + sVar3);
						sStack86 = sVar1 + sStack70;
						local_58 = local_48;
						local_50 = CONCAT22(sStack70 - sVar1, local_48);
						if (psVar9[iVar4] < 500) {
							ShowCarlight((SVECTOR *)&local_58, cp, local_40, 0x11, &light_texture, 0);
						LAB_000300c8:
							ShowCarlight(v1, cp, local_40, 0x11, &light_texture, 0);
							*pcVar8 = *pcVar8 + '\b';
						}
					}
				}
				iVar7 = (int)-sVar1;
				iVar10 = (iVar10 + 1) * 0x10000 >> 0x10;
				local_48 = (short)local_30 - local_48;
			} while (iVar10 < 2);
		}
	}
	return;*/
}



// decompiled code
// original method signature: 
// void /*$ra*/ AddCopCarLight(struct _CAR_DATA *cp /*$t0*/)
 // line 514, offset 0x00030148
	/* begin block 1 */
		// Start line: 515
		// Start offset: 0x00030148
		// Variables:
	// 		int size; // $a3
	// 		int light; // $s1
	// 		int pos; // $s3
	// 		int side; // $s4
	// 		int num_lights; // $t5
	// 		int count_speed; // $t4
	// 		char col1; // $a2
	// 		char col2; // $a1
	// 		static char xpos1[8]; // offset 0x10
	// 		int sign; // $t1
	// 		char *coplife; // $s2
	// 		struct SVECTOR v1; // stack offset -88
	// 		struct CVECTOR col; // stack offset -80
	// 		struct CAR_COSMETICS *car_cos; // $s0
	// 		short cogOffset; // $fp
	/* end block 1 */
	// End offset: 0x00030514
	// End Line: 644

	/* begin block 2 */
		// Start line: 1341
	/* end block 2 */
	// End Line: 1342

	/* begin block 3 */
		// Start line: 1347
	/* end block 3 */
	// End Line: 1348

int main_cop_light_pos = 0;

// [D]
void AddCopCarLight(_CAR_DATA *cp)
{
	static char xpos1[8] = {
		0x30, 0x20, 0x10,  0x0,
		0x0, 0x10, 0x20, 0x30
	};

	short sVar1;
	short sVar2;
	int iVar3;
	int uVar4;
	short sVar5;
	char cVar6;
	int iVar7;
	CAR_COSMETICS *pCVar8;
	char *coplife;
	uint uVar10;
	int iVar11;
	SVECTOR v1;
	CVECTOR col;

	sVar5 = 1;
	coplife = &cp->ap.coplife;

	if (cp < car_data) 
	{
		while (FrameCnt != 0x78654321) {
			trap(0x400);
		}
	}

	if (CameraCar == CAR_INDEX(cp) && cameraview == 2)
		return;

	if (FastForward != 0) 
		return;

	if (cp->hd.where.m[1][1] < 100)
		return;

	pCVar8 = (cp->ap).carCos;
	sVar1 = (pCVar8->cog).vx;

	if (GameLevel == 1 || GameLevel == 3)
	{
		iVar11 = 1;
		iVar7 = 2;
		uVar10 = 3;
		cVar6 = 48;
	}
	else if (GameLevel == 0)
	{
		iVar11 = 2;
		iVar7 = 2;
		uVar10 = 3;
		cVar6 = 16;
	}
	else 
	{
		iVar11 = 2;
		iVar7 = 3;
		cVar6 = 16;
		uVar10 = main_cop_light_pos + CAR_INDEX(cp) & 7;
	}

	do {
		sVar2 = sVar5;
		iVar11--;

		if (iVar11 == -1)
			return;

		iVar3 = iVar7;

		while (iVar3--, sVar5 = -sVar2, iVar3 != -1) 
		{
			v1.vx = sVar1;

			if (GameLevel != 1 && GameLevel != 3) 
				v1.vx = sVar1 + (xpos1[uVar10] + (pCVar8->policeLight).vx) * sVar2;

			col.g = 90;
			v1.vy = pCVar8->policeLight.vy + pCVar8->cog.vy;

			if (gNight != 0)
				col.g = 50;

			if (pauseflag == 0 && (CameraCnt & 1U) != 0 && GameLevel == 2) 
				uVar10++;

			uVar10 = uVar10 & 7;
			v1.vz = (pCVar8->policeLight).vz + (pCVar8->cog).vz;

			uVar4 = *coplife;

			// [A] too entangled...
			if (GameLevel == 1)
			{
			LAB_00030434:
				col.b = -1;
				col.r = col.g;
			}
			else 
			{
				if (1 < GameLevel) 
				{
					if (GameLevel != 3) 
						goto LAB_0003041c;
					goto LAB_00030434;
				}

				if (GameLevel != 0)
				{
				LAB_0003041c:
					if (iVar11 == 0) 
						goto LAB_00030434;
				}

				col.r = -1;
				col.b = col.g;
			}

			if (pauseflag == 0) 
				cp->ap.coplife += cVar6;

			ShowCarlight(&v1, cp, &col, uVar4 >> 1, &light_texture, 0xff);

			if (pauseflag == 0 && (CameraCnt & 1U) != 0 && GameLevel == 2) 
				uVar10++;

			uVar10 = uVar10 & 7;
		}

	} while (true);
}



// decompiled code
// original method signature: 
// void /*$ra*/ AddNightLights(struct _CAR_DATA *cp /*$s6*/)
 // line 653, offset 0x00030544
	/* begin block 1 */
		// Start line: 654
		// Start offset: 0x00030544
		// Variables:
	// 		static struct MATRIX work_matrix; // offset 0x0
	// 		struct CAR_COSMETICS *car_cos; // $fp
	// 		struct SVECTOR Position1; // stack offset -104
	// 		struct SVECTOR Position2; // stack offset -96
	// 		struct SVECTOR vec; // stack offset -88
	// 		struct CVECTOR col; // stack offset -80
	// 		int lit; // stack offset -72
	// 		int lightFlag; // $t0
	// 		char *life2; // stack offset -68
	// 		short damIndex; // $s5
	// 		short loop; // stack offset -64
	// 		short offset; // $s2
	// 		short doubleFlag; // stack offset -60
	// 		short verticalFlag; // stack offset -56
	// 		short cogOffset; // stack offset -52
	/* end block 1 */
	// End offset: 0x00030D9C
	// End Line: 919

	/* begin block 2 */
		// Start line: 1653
	/* end block 2 */
	// End Line: 1654

	/* begin block 3 */
		// Start line: 1663
	/* end block 3 */
	// End Line: 1664

/* WARNING: Could not reconcile some variable overlaps */

int gPlayerCarLights = 0;
int gcar_num = 0;

// [D]
void AddNightLights(_CAR_DATA *cp)
{
	short sVar1;
	short sVar2;
	ushort uVar3;
	short sVar4;
	char cVar5;
	ushort uVar6;
	uint uVar8;
	uint uVar9;
	int iVar10;
	char cVar11;
	int iVar12;
	short *psVar13;
	CAR_COSMETICS *pCVar14;
	SVECTOR Position1;
	SVECTOR Position2;
	SVECTOR vec;
	CVECTOR col;
	int lit;
	char *life2;
	short loop;
	short doubleFlag;
	short verticalFlag;
	short cogOffset;
	short *local_2c;

	life2 = &cp->ap.life2;

	lit = 0;
	loop = 0;
	LeftLight = 0;
	RightLight = 0;

	pCVar14 = cp->ap.carCos;
	uVar3 = pCVar14->extraInfo;
	psVar13 = cp->ap.damage;

	sVar1 = pCVar14->cog.vx;
	gcar_num = CAR_INDEX(cp);

	vec.vx = pCVar14->headLight.vx + pCVar14->cog.vx;
	vec.vy = pCVar14->headLight.vy + pCVar14->cog.vy;
	vec.vz = pCVar14->headLight.vz + pCVar14->cog.vz;
	iVar10 = (((uint)(ushort)pCVar14->extraInfo & 0xc00) >> 8) + 10;
	vec.vz = vec.vz + pCVar14->cog.vz;

	do {
		cVar11 = 0;
		uVar8 = 8 << (loop & 0x1f);
		sVar4 = (short)iVar10;
		iVar10 = lit;

		if ((uVar3 & 0x8000) == 0) 
		{
			Position1.vx = vec.vx;
			Position1.vy = vec.vy;
			sVar2 = *psVar13 >> 6;
			Position1.vz = (vec.vz + sVar2);
			Position2.vz = (vec.vz + sVar2);

			if (*psVar13 < 1000) 
			{
				cVar11 = 1;

				col.r = -1;
				col.b = -1;
				col.g = -1;

				ShowCarlight(&Position1, cp, &col, 20, &light_texture, uVar8 & 0xff | 1);
				iVar10 = lit + 1;
			}
		}
		else if ((uVar3 & 0x2000) == 0)
		{
			sVar2 = *psVar13 >> 6;
			Position1.vz = vec.vz + sVar2;
			Position2.vz = vec.vz + sVar2;

			Position1.vx = sVar4 + vec.vx;
			Position1.vy = vec.vy;

			Position2.vx = vec.vx - sVar4;
			Position2.vy = vec.vy;

			if (*psVar13 < 1000) 
			{
				col.r = -1;
				col.b = -1;
				col.g = -1;
				ShowCarlight(&Position1, cp, &col, 0x14, &light_texture, uVar8 & 0xff | 1);
				sVar2 = (cp->ap).damage[0];
				goto joined_r0x00030874;
			}
		}
		else 
		{
			sVar2 = *psVar13 >> 6;
			Position1.vz = vec.vz + sVar2;
			Position2.vz = vec.vz + sVar2;
			Position1.vy = sVar4 + vec.vy;
			Position2.vy = vec.vy - sVar4;

			if (*psVar13 < 1000)
			{
				col.r = -1;
				col.b = -1;
				col.g = -1;
				ShowCarlight(&Position1, cp, &col, 20, &light_texture, uVar8 & 0xff | 1);
				sVar2 = *psVar13;
			joined_r0x00030874:
				cVar11 = 1;
				iVar10 = lit + 1;

				if (sVar2 < 500) 
				{
					lit = lit + 2;
					cVar11 = 2;
					col.r = -1;
					col.b = -1;
					col.g = -1;
					ShowCarlight(&Position2, cp, &col, 20, &light_texture, 1);
					iVar10 = lit;
				}
			}
		}

		lit = iVar10;
		local_2c = cp->ap.damage;
		iVar10 = -sVar4;
		vec.vx = sVar1 * 2 - vec.vx;
		cVar5 = cVar11;

		if (loop == 0) 
		{
			cVar5 = RightLight;
			LeftLight = cVar11;
		}

		RightLight = cVar5;
		psVar13 = psVar13 + 1;
		loop = ((loop + 1) * 0x10000) >> 0x10;

		if (1 < loop)
		{
			col.r = 56;

			if (cp->controlType != 1)
				col.r = 1;

			col.b = 0;
			col.g = 0;

			uVar3 = pCVar14->extraInfo;

			vec.vx = pCVar14->brakeLight.vx + pCVar14->cog.vx;
			vec.vy = pCVar14->brakeLight.vy + pCVar14->cog.vy;
			vec.vz = pCVar14->brakeLight.vz + pCVar14->cog.vz;

			iVar10 = ((pCVar14->extraInfo & 0x300) >> 6) + 10;

			if ((pCVar14->extraInfo & 8U) != 0) 
			{
				loop = 0;

				do {
					uVar8 = 2 << (loop & 0x1f);
					iVar12 = ((4 - loop) * 0x10000) >> 0x10;
					sVar4 = iVar10;

					if ((uVar3 & 0x4000) == 0)
					{
						Position1 = vec;

						if (local_2c[iVar12] < 500)
						{
							ShowCarlight(&Position1, cp, &col, 17, &light_texture, uVar8 & 0xff);

							*life2 = *life2 + 16;
						}
					}
					else 
					{
						if ((uVar3 & 0x1000) == 0) 
						{
							sVar2 = local_2c[iVar12];
							Position1.vx = sVar4 + vec.vx;
							Position2.vx = vec.vx - sVar4;

							Position1.vy = vec.vy;
							Position2.vy = vec.vy;
						}
						else
						{
							sVar2 = local_2c[iVar12];
							Position1.vy = sVar4 + vec.vy;
							Position2.vy = vec.vy - sVar4;

							Position1.vx = vec.vx;
							Position2.vx = vec.vx;
						}

						Position2.vz = vec.vz + (sVar2 >> 6);
						Position1.vz = vec.vz + (sVar2 >> 6);

						if (sVar2 < 500)
						{
							ShowCarlight(&Position1, cp, &col, 17, &light_texture, uVar8 & 0xff);
							ShowCarlight(&Position2, cp, &col, 17, &light_texture, 0);

							*life2 = *life2 + 16;
						}
					}

					iVar10 = -sVar4;
					loop = ((loop + 1) * 0x10000) >> 0x10;
					vec.vx = sVar1 * 2 - vec.vx;
				} while (loop < 2);
			}
			if (lit != 0) 
			{
				col.r = (lit << 4);
				col.g = col.r;
				col.b = col.r;
				PlacePoolForCar(cp, &col, 1);
			}

			if (col.r != 0) 
			{
				col.b = 0;
				col.g = 0;
				col.r = 0;
				PlacePoolForCar(cp, &col, 0);
			}

			if (cp->controlType == 1)
				gPlayerCarLights = lit;

			return;
		}
	} while (true);
}



// decompiled code
// original method signature: 
// void /*$ra*/ AddSmokingEngine(struct _CAR_DATA *cp /*$s0*/, int black_smoke /*$s2*/, int WheelSpeed /*$s3*/)
 // line 989, offset 0x00030d9c
	/* begin block 1 */
		// Start line: 990
		// Start offset: 0x00030D9C
		// Variables:
	// 		struct VECTOR SmokePos; // stack offset -64
	// 		struct CAR_COSMETICS *car_cos; // $a0
	// 		struct VECTOR Drift; // stack offset -48
	// 		struct SVECTOR svec; // stack offset -32
	/* end block 1 */
	// End offset: 0x00030F90
	// End Line: 1038

	/* begin block 2 */
		// Start line: 3039
	/* end block 2 */
	// End Line: 3040

/* WARNING: Could not reconcile some variable overlaps */

void AddSmokingEngine(_CAR_DATA *cp, int black_smoke, int WheelSpeed)
{
	UNIMPLEMENTED();
	/*
	int iVar1;
	uint uVar2;
	CAR_COSMETICS *pCVar3;
	VECTOR local_40;
	VECTOR VStack48;
	undefined4 local_20;
	uint local_1c;

	if (cp < car_data) {
		while (FrameCnt != 0x78654321) {
			trap(0x400);
		}
	}
	if ((((CameraCnt & 3U) == ((int)(cp[-0x503].ap.old_clock + 2) * -0x24ca58e9 >> 2 & 3U)) &&
		(gDoSmoke != 0)) && (pauseflag == 0)) {
		pCVar3 = (cp->ap).carCos;
		uVar2 = *(uint *)&(pCVar3->smoke).vz;
		local_20._0_2_ = (short)*(undefined4 *)&pCVar3->smoke;
		local_20._0_2_ = (short)local_20 + (pCVar3->cog).vx;
		local_20._2_2_ = (short)((uint)*(undefined4 *)&pCVar3->smoke >> 0x10);
		local_20._2_2_ = local_20._2_2_ + (pCVar3->cog).vy;
		local_1c._0_2_ = (short)uVar2;
		local_1c = uVar2 & 0xffff0000 | (uint)(ushort)((short)local_1c + (pCVar3->cog).vz);
		iVar1 = rand();
		local_40.vx = (cp->hd).where.t[0];
		local_20 = CONCAT22(local_20._2_2_, ((ushort)iVar1 & 0x7f) - 0x40);
		local_40.vz = (cp->hd).where.t[2];
		local_40.vy = -(cp->hd).where.t[1];
		if (black_smoke != 0) {
			local_40.vy = local_40.vy + -0x32;
		}
		setCopControlWord(2, 0, *(undefined4 *)(cp->hd).drawCarMat.m);
		setCopControlWord(2, 0x800, *(undefined4 *)((cp->hd).drawCarMat.m + 2));
		setCopControlWord(2, 0x1000, *(undefined4 *)((cp->hd).drawCarMat.m + 4));
		setCopControlWord(2, 0x1800, *(undefined4 *)((cp->hd).drawCarMat.m + 6));
		setCopControlWord(2, 0x2000, *(undefined4 *)((cp->hd).drawCarMat.m + 8));
		InitFXPos(&local_40, (SVECTOR *)&local_20, cp);
		GetSmokeDrift(&VStack48);
		if (black_smoke == 0) {
			Setup_Smoke(&local_40, 100, 400, 2, WheelSpeed, &VStack48, 0);
		}
		else {
			Setup_Smoke(&local_40, 100, 500, 1, WheelSpeed, &VStack48, 0);
		}
	}
	return;*/
}



// decompiled code
// original method signature: 
// void /*$ra*/ AddFlamingEngine(struct _CAR_DATA *cp /*$s1*/)
 // line 1048, offset 0x00030fac
	/* begin block 1 */
		// Start line: 1049
		// Start offset: 0x00030FAC
		// Variables:
	// 		struct VECTOR SmokePos; // stack offset -56
	// 		struct SVECTOR svec; // stack offset -40
	// 		struct CAR_COSMETICS *car_cos; // $a0
	// 		struct VECTOR Drift; // stack offset -32
	/* end block 1 */
	// End offset: 0x0003114C
	// End Line: 1084

	/* begin block 2 */
		// Start line: 3174
	/* end block 2 */
	// End Line: 3175

/* WARNING: Could not reconcile some variable overlaps */

void AddFlamingEngine(_CAR_DATA *cp)
{
	UNIMPLEMENTED();
	/*
	int iVar1;
	uint uVar2;
	CAR_COSMETICS *pCVar3;
	VECTOR local_38;
	undefined4 local_28;
	uint local_24;
	VECTOR local_20;

	if (cp < car_data) {
		while (FrameCnt != 0x78654321) {
			trap(0x400);
		}
	}
	if ((((CameraCnt & 1U) == ((int)(cp[-0x503].ap.old_clock + 2) * -0x24ca58e9 >> 2 & 1U)) &&
		(pCVar3 = (cp->ap).carCos, gDoSmoke != 0)) && (pauseflag == 0)) {
		uVar2 = *(uint *)&(pCVar3->fire).vz;
		local_28._0_2_ = (short)*(undefined4 *)&pCVar3->fire;
		local_28._0_2_ = (short)local_28 + (pCVar3->cog).vx;
		local_28._2_2_ = (short)((uint)*(undefined4 *)&pCVar3->fire >> 0x10);
		local_28._2_2_ = local_28._2_2_ + (pCVar3->cog).vy;
		local_24._0_2_ = (short)uVar2;
		local_24 = uVar2 & 0xffff0000 | (uint)(ushort)((short)local_24 + (pCVar3->cog).vz);
		iVar1 = rand();
		local_28 = CONCAT22(local_28._2_2_, (short)local_28 + ((ushort)iVar1 & 0x3f));
		iVar1 = rand();
		local_38.vx = (cp->hd).where.t[0];
		local_24 = local_24 & 0xffff0000 | (uint)(ushort)((short)local_24 + ((ushort)iVar1 & 0x3f));
		local_38.vz = (cp->hd).where.t[2];
		local_38.vy = -(cp->hd).where.t[1];
		SetRotMatrix(&(cp->hd).drawCarMat);
		InitFXPos(&local_38, (SVECTOR *)&local_28, cp);
		local_20.vx = 0;
		local_20.vy = 0;
		local_20.vz = 0;
		Setup_Smoke(&local_38, 0x32, 100, 4, 0, &local_20, 0);
	}
	return;
	*/
}





